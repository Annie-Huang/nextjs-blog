https://nextjs.org/docs/routing/introduction

##################################################################################

Routing
-------------------
Index routes

        pages/index.js → /
        pages/blog/index.js → /blog

Nested routes

        pages/blog/first-post.js → /blog/first-post
        pages/dashboard/settings/username.js → /dashboard/settings/username

Dynamic route segments

        pages/blog/[slug].js → /blog/:slug (/blog/hello-world)
        pages/[username]/settings.js → /:username/settings (/foo/settings)
        pages/post/[...all].js → /post/* (/post/2020/id/title)


Linking between pages
--------------------------
Any <Link /> in the viewport (initially or through scroll) will be prefetched by default (including the corresponding data) for pages using Static Generation. The corresponding data for server-rendered routes is not prefetched.
        / → pages/index.js
        /about → pages/about.js
        /blog/hello-world → pages/blog/[slug].js

        -------------------------------------

        import Link from 'next/link'

        function Home() {
          return (
            <ul>
              <li>
                <Link href="/">
                  <a>Home</a>
                </Link>
              </li>
              <li>
                <Link href="/about">
                  <a>About Us</a>
                </Link>
              </li>
              <li>
                <Link href="/blog/hello-world">
                  <a>Blog Post</a>
                </Link>
              </li>
            </ul>
          )
        }

        export default Home


Linking to dynamic paths
--------------------------------
You can also use interpolation to create the path, which comes in handy for dynamic route segments.
encodeURIComponent is used in the example to keep the path utf-8 compatible.

        import Link from 'next/link'

        function Posts({ posts }) {
          return (
            <ul>
              {posts.map((post) => (
                <li key={post.id}>
                  <Link href={`/blog/${encodeURIComponent(post.slug)}`}>
                    <a>{post.title}</a>
                  </Link>
                </li>
              ))}
            </ul>
          )
        }

        export default Posts

        -------------------------------------

Alternatively, using a URL Object:
pathname is the name of the page in the pages directory. /blog/[slug] in this case.
query is an object with the dynamic segment. slug in this case.

        import Link from 'next/link'

        function Posts({ posts }) {
          return (
            <ul>
              {posts.map((post) => (
                <li key={post.id}>
                  <Link
                    href={{
                      pathname: '/blog/[slug]',
                      query: { slug: post.slug },
                    }}
                  >
                    <a>{post.title}</a>
                  </Link>
                </li>
              ))}
            </ul>
          )
        }

        export default Posts


Dynamic Routes (use router info in component)
-----------------------------------------------------------------
To access the router object in a React component you can use useRouter or withRouter.

        import { useRouter } from 'next/router'

        const Post = () => {
          const router = useRouter()
          const { pid } = router.query

          return <p>Post: {pid}</p>
        }

        export default Post

        -------------------------------------

pages/post/[pid].js:
        /post/abc               { "pid": "abc" }
        /post/abc?foo=bar       { "foo": "bar", "pid": "abc" }
        /post/abc?pid=123       { "pid": "abc" }

        -------------------------------------

pages/post/[pid]/[comment].js:
        /post/abc/a-comment     { "pid": "abc", "comment": "a-comment" }


Catch all routes:
----------------------
Dynamic routes can be extended to catch all paths by adding three dots (...) inside the brackets. For example:

        pages/post/[...slug].js     /post/a, but also
                                    /post/a/b,
                                    /post/a/b/c and so on.

        /post/a         { "slug": ["a"] }
        /post/a/b       { "slug": ["a", "b"] }


Optional catch all routes
-----------------------------------
Catch all routes can be made optional by including the parameter in double brackets ([[...slug]]).

        pages/post/[[...slug]].js   /post,
                                    /post/a,
                                    /post/a/b,

The main difference between catch all and optional catch all routes is that with optional, the route without the parameter is also matched (/post in the example above).

        { } // GET `/post` (empty object)
        { "slug": ["a"] } // `GET /post/a` (single-element array)
        { "slug": ["a", "b"] } // `GET /post/a/b` (multi-element array)


Order
--------------
!!!!!
Predefined routes take precedence over dynamic routes, and dynamic routes over catch all routes. Take a look at the following examples:

We can go to the following path:
- /post/create
- /post/1,
- /post/abc,
- /post/1/2,
- /post/a/b/c

And we have
- pages/post/create.js
- pages/post/[pid].js
- pages/post/[...slug].js

        pages/post/create.js - Will match /post/create
        pages/post/[pid].js - Will match /post/1, /post/abc, etc. But not /post/create
        pages/post/[...slug].js - Will match /post/1/2, /post/a/b/c, etc. But not /post/create, /post/abc


Pages that are statically optimized by Automatic Static Optimization will be hydrated without their route parameters provided, i.e query will be an empty object ({}).









